<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Buffer

load_constants();

// D for DOOR; Door_byte_breakdown
global.D[0] = $38000; 
global.D[1] = $7000; 
global.D[2] = $E00; 
global.D[3] = $1C0;
// B for BYTE; Map_byte_breakdown
global.B[0] = $FF00000000;
global.B[1] = $FF000000;
global.B[2] = $FF0000;
global.B[3] = $FF00;
global.B[4] = $FF;
// U for UNCOVER; Map_discoveries
global.U[0] = $3;
global.U[1] = $C;
global.U[2] = $30;
global.U[3] = $C0;
// N for NUNCOVER; Map_disc_inverse
global.N[0] = $FC;
global.N[1] = $F3;
global.N[2] = $CF;
global.N[3] = $3F;
// H for H...?; Map_bitshift_get
global.H[0] = 0;
global.H[1] = 2;
global.H[2] = 4;
global.H[3] = 6;
// BL for BITLEFT
global.BL[0] = 32;
global.BL[1] = 24;
global.BL[2] = 16;
global.BL[3] = 8;
global.BL[4] = 0;


Key[0] = ord("A");
Key[1] = ord("W");
Key[2] = ord("D");
Key[3] = ord("S");

Dir[0] = "L";
Dir[1] = "T";
Dir[2] = "R";
Dir[3] = "B";


FindTPTarget = 0;
Message = "";
MessageTime = 0;

MapBuffer = buffer_create(82432,buffer_fast,1);
buffer_fill(MapBuffer,0,buffer_u8,0,82432);

DiscBuffer = buffer_create(4096, buffer_fast, 1);
buffer_fill(DiscBuffer,0,buffer_u8,0,4096);
          
CurrentWorld = 0;
Color = 1;
Marker = 0;
RoomID = 0;


// 16 room, 6 color, 12 door, 6 marker,    5 bytes total

Cursor = surface_create(8,8);

for (i=0;i&lt;4;i++)
{
 Door[i] = 0;
}
 
buffer_seek(MapBuffer,buffer_seek_start,0);
buffer_write(MapBuffer,buffer_u8, 16);

for (i=0;i&lt;16;i++)
{
 Name = "NULL WORLD " + string(i);
 buffer_seek(MapBuffer,buffer_seek_start,16+(i*16));
 for (h=1;h&lt;=min(16,string_length(Name));h++)
 {
  buffer_write(MapBuffer,buffer_u8, ord(string_char_at(Name,h)));
 }
}

CursorValue = 0; // Current Cursor 5-byte Value
CursorX = 0;
CursorY = 0;

MapStartExists = 0;
MapStart[0] = 0; //w
MapStart[1] = 0; //x
MapStart[2] = 0; //y

window_set_cursor(cr_none);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>surface_free(Cursor);
buffer_delete(MapBuffer);
buffer_delete(DiscBuffer);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Buffer Draw

buffer_seek(MapBuffer, buffer_seek_start, 32);

if MessageTime MessageTime--;

/// World Switch

if keyboard_check_pressed(vk_right)
{
 CurrentWorld += 1;
 if CurrentWorld &gt; 15 CurrentWorld = 0;
}
if keyboard_check_pressed(vk_left)
{
 CurrentWorld -= 1;
 if CurrentWorld &lt; 0 CurrentWorld = 15;
}
    
/// Wall Update

if !FindTPTarget
{
 for (i=0;i&lt;4;i++)
 if keyboard_check_pressed(Key[i])
  Door[i] = (Door[i]+1)-(7*(Door[i]&gt;5));
}
else
{
 for (i=0;i&lt;4;i++)
 if keyboard_check_pressed(Key[i])
  NewTPD = i+1;
}
 
/// Cursor Draw

CursorX = (mouse_x&amp;$FFF8);
CursorY = (mouse_y&amp;$FFF8)

if mouse_x &gt;= 64 &amp;&amp; mouse_y &gt;= 64
{ 
 MapX = (CursorX&gt;&gt;3) - 8;
 MapY = (CursorY&gt;&gt;3) - 8;
 
 if !surface_exists(Cursor) Cursor = surface_create(8,8);
 surface_set_target(Cursor);
 draw_clear_alpha(c_black,0);

 draw_sprite_ext(sMMapColor, Color, 0, 0,1,1,0,c_white,1);
 
 if Color != 5
 {
  for (i=0;i&lt;4;i++)
  {
   draw_sprite_ext(sMMapSides, (Door[i]&lt;&lt;2)+i, 0, 0,1,1,0,c_white,1);
  }      
          
  draw_sprite_ext(sMMapMarks, Marker, 0, 0,1,1,0,c_white,1); 
 }
 
 surface_reset_target();
 
 /// Set TILE
 
 if mouse_check_button(mb_left)
 if Color != 5
 {
  map_update_cursor();
  buffer_seek(MapBuffer, buffer_seek_start, 512+(CurrentWorld&lt;&lt;10)+(CurrentWorld&lt;&lt;12)+((MapX+(MapY&lt;&lt;5))*5));
    
  for (i=0;i&lt;5;i++)
  {
   buffer_write(MapBuffer,buffer_u8, map_get_byte(CursorValue,i));
  }
 }
 
 if Color == 5
 if mouse_check_button_pressed(mb_left)
 {
  if FindTPTarget == 0
  {
   Overwrite = 0;
   for (i=0;i&lt;60;i++) // Make sure not clicking on already existing TP
   {    
    buffer_seek(MapBuffer, buffer_seek_start, 272 + (i&lt;&lt;2));
    
    CTByte = (buffer_read(MapBuffer,buffer_u8)&lt;&lt;24)+(buffer_read(MapBuffer,buffer_u8)&lt;&lt;16)
           + (buffer_read(MapBuffer,buffer_u8)&lt;&lt;8)+(buffer_read(MapBuffer,buffer_u8)) 
           
    CPWorld = (CTByte &amp; $F0000000) &gt;&gt; 28;
    CPD = (CTByte &amp; $F);
    
    if CurrentWorld == CPWorld
    if CPD != 0
    {
     CPTWorld = (CTByte &amp; $F000000) &gt;&gt; 24;
     CPX = (CTByte &amp; $F80000) &gt;&gt; 19;
     CPY = (CTByte &amp; $7C000) &gt;&gt; 14;
     
     if floor(CPX) == floor(MapX) &amp;&amp; floor(CPY) == floor(MapY)
     {
      Overwrite = 1;
      break;
     }
    }
   }
   
   if !Overwrite
   {
    // Find empty TP slot
    Found = -1;
    for (i=0;i&lt;60;i++)
    {
     buffer_seek(MapBuffer, buffer_seek_start, 272 + (i&lt;&lt;2));
  
     TByte = (buffer_read(MapBuffer,buffer_u8)&lt;&lt;24)+(buffer_read(MapBuffer,buffer_u8)&lt;&lt;16)
            + (buffer_read(MapBuffer,buffer_u8)&lt;&lt;8)+(buffer_read(MapBuffer,buffer_u8)) 
            
     PD = (TByte &amp; $F);
    
     if PD == 0
     {
      Found = i;   
      NewTPS = Found;
      break;
     }
    }
    
    if Found == -1
    {
     Message = "@4NO TP SLOT LEFT";
     MessageTime = 90;
    }
    else
    {    
     NewTPX = MapX;
     NewTPY = MapY;
     NewTPW = CurrentWorld;
     NewTPD = 1;
     FindTPTarget = 1;  
    }   
   }
  }
  else
  if !(NewTPX == MapX &amp;&amp; NewTPY == MapY &amp;&amp; CurrentWorld == NewTPW)
  {
   NewTPTX = MapX;
   NewTPTY = MapY;
   NewTPTW = CurrentWorld;
   
   // 4 bytes per TP Bits: WWWWTTTT XXXXXYYY YYxxxxxy yyyyDDDD 
   
   NewTPByte = (NewTPW &lt;&lt; 28) + (NewTPTW &lt;&lt; 24) + (NewTPX &lt;&lt; 19) + (NewTPY &lt;&lt; 14) + (NewTPTX &lt;&lt; 9) + (NewTPTY &lt;&lt; 4) + NewTPD;
   
   buffer_seek(MapBuffer, buffer_seek_start, 272 + (NewTPS&lt;&lt;2));
   repeat (4) buffer_write(MapBuffer,buffer_u8,8);
   buffer_seek(MapBuffer, buffer_seek_start, 272 + (NewTPS&lt;&lt;2));
   buffer_write(MapBuffer,buffer_u8,(NewTPByte &amp; $FF000000)&gt;&gt;24);
   buffer_write(MapBuffer,buffer_u8,(NewTPByte &amp; $FF0000)&gt;&gt;16);
   buffer_write(MapBuffer,buffer_u8,(NewTPByte &amp; $FF00)&gt;&gt;8);
   buffer_write(MapBuffer,buffer_u8,NewTPByte &amp; $FF);   
   
   FindTPTarget = 0;
   MessageTime = 240;                      
   Message = "@2TP SET (@3SLOT" +string(NewTPS)+"@2) VALUE: @5" + string(NewTPByte); 
  }
 }

 
 // Delete TILE
 if mouse_check_button(mb_right)
 {
  buffer_seek(MapBuffer, buffer_seek_start, 512+(CurrentWorld&lt;&lt;10)+(CurrentWorld&lt;&lt;12)+((MapX+(MapY&lt;&lt;5))*5));    
  repeat (5)
  {
   buffer_write(MapBuffer,buffer_u8, 0);
  }
   
  for (i=0;i&lt;60;i++)
  {
   buffer_seek(MapBuffer, buffer_seek_start, 272 + (i&lt;&lt;2));

   CTByte = (buffer_read(MapBuffer,buffer_u8)&lt;&lt;24)+(buffer_read(MapBuffer,buffer_u8)&lt;&lt;16)
          + (buffer_read(MapBuffer,buffer_u8)&lt;&lt;8)+(buffer_read(MapBuffer,buffer_u8)) 
   
   CPWorld = (CTByte &amp; $F0000000) &gt;&gt; 28;

   if CurrentWorld == CPWorld
   {
    CPX = (CTByte &amp; $F80000) &gt;&gt; 19;
    CPY = (CTByte &amp; $7C000) &gt;&gt; 14;
    
    if MapX == CPX &amp;&amp; MapY == CPY
    {
     buffer_seek(MapBuffer, buffer_seek_start, 272 + (i&lt;&lt;2));
     repeat (4) buffer_write(MapBuffer,buffer_u8,0);
     break;
    }
   }
  }
 } 
}

if FindTPTarget 
{
 MessageTime = 1;
 Message = "@3POINT TO TP EXIT (DIR: @1"+Dir[NewTPD-1]+"@3) (ESC CANCEL)";
 if NewTPW == CurrentWorld
 draw_sprite_ext(sMMapColor, 5, (NewTPX&lt;&lt;3)+64, (NewTPY&lt;&lt;3)+64,1,1,0,c_white,1);  
 
 if keyboard_check_pressed(vk_escape)
 {
  FindTPTarget = 0
 }  
}

// Map Draw                                                                                                                                       

RoomText = "";

for (i=0;i&lt;32;i++)
for (j=0;j&lt;32;j++)
{
 buffer_seek(MapBuffer, buffer_seek_start, 512+(CurrentWorld&lt;&lt;10)+(CurrentWorld&lt;&lt;12)+((i+(j&lt;&lt;5))*5));  
 
 for (bb=0;bb&lt;5;bb++)
 {
  Byte[bb] = buffer_read(MapBuffer,buffer_u8)
 }
  
 MainByte = (Byte[0]&lt;&lt;32)+(Byte[1]&lt;&lt;24)+(Byte[2]&lt;&lt;16)+(Byte[3]&lt;&lt;8)+Byte[4];  
  
 if MainByte != 0
 {
  TileColor = map_get_info(MainByte, 1);
  for (dd=0;dd&lt;4;dd++)
   TileDoor[dd] = map_get_info(MainByte, 2+dd);
  
  TileMark = map_get_info(MainByte, 6);
  
  draw_sprite_ext(sMMapColor, TileColor, (i&lt;&lt;3)+64, (j&lt;&lt;3)+64,1,1,0,c_white,1);
  
  for (ii=0;ii&lt;4;ii++)
  {
   if TileDoor[ii] != 0
    draw_sprite_ext(sMMapSides, (TileDoor[ii]&lt;&lt;2)+ii, (i&lt;&lt;3)+64, (j&lt;&lt;3)+64,1,1,0,c_white,1);
  }             
  
  if TileMark != 0
  draw_sprite_ext(sMMapMarks, TileMark, (i&lt;&lt;3)+64, (j&lt;&lt;3)+64,1,1,0,c_white,1); 
  
  if MapX == i &amp;&amp; MapY == j
  {
   RoomText = string(i)+":"+string(j) + " ROOM: " + string(map_get_info(MainByte,0));  
  }
 }
 
 if MapStartExists
 if MapStart[0] == CurrentWorld
 if MapStart[1] == i
 if MapStart[2] == j
  draw_sprite_ext(sMMapMarks, 9, (i&lt;&lt;3)+64, (j&lt;&lt;3)+64,1,1,0,c_white,.5); 
} 


/// Draw TPs

for (i=0;i&lt;60;i++)
{
 // DDDD = Direction. 0: No Exist, 1 L, 2 T, 3 R, 4 B
 // 4 bytes per TP Bits: WWWWTTTT XXXXXYYY YYxxxxxy yyyyDDDD 
 
 buffer_seek(MapBuffer, buffer_seek_start, 272 + (i&lt;&lt;2));
 
 TByte = (buffer_read(MapBuffer,buffer_u8)&lt;&lt;24)+(buffer_read(MapBuffer,buffer_u8)&lt;&lt;16)
        + (buffer_read(MapBuffer,buffer_u8)&lt;&lt;8)+(buffer_read(MapBuffer,buffer_u8)) 
        
 PWorld = (TByte &amp; $F0000000) &gt;&gt; 28;
 PD = (TByte &amp; $F);
 
 if CurrentWorld == PWorld
 if PD != 0
 {
  PTWorld = (TByte &amp; $F000000) &gt;&gt; 24;
  PX = (TByte &amp; $F80000) &gt;&gt; 19;
  PY = (TByte &amp; $7C000) &gt;&gt; 14;
  PTX = (TByte &amp; $3E00) &gt;&gt; 9;
  PTY = (TByte &amp; $1F0) &gt;&gt; 4;
  
  draw_sprite_ext(sMMapColor, 5, (PX&lt;&lt;3)+64, (PY&lt;&lt;3)+64,1,1,0,c_white,.5);  
  
  if !FindTPTarget
  {
   if MapX == PX &amp;&amp; MapY == PY
   {
    if string_copy(Message,0,7) != "@3POINT"
    {
     MessageTime = 1;
     Message = "TP SLOT @2" + string(i) + "@0 ("  + string(PWorld) + ":" + string(PX) + ":" + string(PY)+") to ("+string(PTWorld)+":"+string(PTX)+":"+string(PTY)+") direction @5" + Dir[PD-1];
     if PTWorld == PWorld
     {
      draw_sprite_ext(sMMapColor, 5, (PTX&lt;&lt;3)+64, (PTY&lt;&lt;3)+64,1,1,0,c_yellow,.5); 
      draw_set_color(c_white);
      draw_arrow((PX&lt;&lt;3)+68,(PY&lt;&lt;3)+68,(PTX&lt;&lt;3)+68,(PTY&lt;&lt;3)+68,4); 
     }
    }
   }  
  }
 }
}

/// HUD

draw_set_color(c_black);
draw_rectangle(0,0,room_width,63,0);
draw_rectangle(0,0,63,room_height,0);
draw_set_color(c_white);

// Draw Colors

ColX = 16;
ColY = 32;

for (i=0;i&lt;sprite_get_number(sMMapColor);i++)
{
 draw_sprite_ext(sMMapColor,i,ColX,ColY+i*8,1,1,0,c_white,1);
 
 if point_in_rectangle(mouse_x,mouse_y,ColX,ColY+i*8,ColX+8,ColY+i*8+8)
 if mouse_check_button(mb_left)
 if !FindTPTarget
 {
  Color = i;
 }
}

draw_set_color(c_blue);
draw_rectangle(ColX-1,ColY-1,ColX+8,ColY+48,1);

for (i=0;i&lt;sprite_get_number(sMMapColor);i++)
{
 if Color == i
  draw_sprite_ext(sSubMarker,0,ColX,ColY+i*8,1,1,0,c_white,1); 
}

// Draw Markers

ColX = 40;
ColY = 32;

for (i=0;i&lt;sprite_get_number(sMMapMarks);i++)
{
 draw_sprite_ext(sMMapMarks,i,ColX,ColY+i*8,1,1,0,c_white,1);
 
 if point_in_rectangle(mouse_x,mouse_y,ColX,ColY+i*8,ColX+8,ColY+i*8+8)
 if mouse_check_button(mb_left)
 if !FindTPTarget
 {
  Marker = i;
 }
}

draw_set_color(c_blue);
draw_rectangle(ColX-1,ColY-1,ColX+8,ColY+48,1);

for (i=0;i&lt;sprite_get_number(sMMapMarks);i++)
{
 if Marker == i
  draw_sprite_ext(sSubMarker,0,ColX,ColY+i*8,1,1,0,c_white,1); 
}

draw_sprite_ext(sSubMarker, 0, CursorX, CursorY,1,1,0,c_white,.75);
if mouse_x&gt;=64 &amp;&amp; mouse_y&gt;=64
 draw_surface_ext(Cursor,CursorX,CursorY,1,1,0,c_white,.5);

/// WOrld NAme

buffer_seek(MapBuffer,buffer_seek_start,16+(CurrentWorld*16));
WorldName = "";

repeat (16)
{
 NameRead = buffer_read(MapBuffer,buffer_u8);
 
 if NameRead == 0 // if NULL character found 
 break;
 else
 WorldName += chr(NameRead);
}

draw_text_adv(2,-2,"@1"+WorldName,1);
draw_text_adv((string_length(WorldName)&lt;&lt;3)+2,-2,"- @5[N] TO NAME WORLD " + string(CurrentWorld),1);

if MessageTime
 draw_text_adv(2,10, Message,1);

if keyboard_check_pressed(ord("N"))
{
 String = get_string("WORLD NAME FOR WORLD " + string(CurrentWorld), "");
 
 if String != ""
 {
  buffer_seek(MapBuffer,buffer_seek_start,16+(CurrentWorld&lt;&lt;4)); 
  for (h=1;h&lt;=16;h++)
  {
   if h &lt;= string_length(String)
   buffer_write(MapBuffer,buffer_u8, ord(string_char_at(String,h)));
   else
   buffer_write(MapBuffer,buffer_u8, 0);
  }  
 }
}

// Load BUFFER

if keyboard_check_pressed(ord("L"))
{
 NewFile = file_text_open_read("MapBuffer.buf");
 BufferString = file_text_read_string(NewFile);
 file_text_close(NewFile);
 
 buffer_base64_decode_ext(MapBuffer,BufferString,0);
}

// Save BUFFER

if keyboard_check_pressed(vk_space)
{
 NewFile = file_text_open_write("MapBuffer.buf");
 file_text_write_string(NewFile, buffer_base64_encode(MapBuffer, 0, 82432));
 file_text_close(NewFile);
}

// ROOM ID CHANGE

if keyboard_check_pressed(ord("R"))
{ 
 RoomID = real(get_string("ROOM ID:",""));
}

draw_text_adv(63,30, "@3ROOM ID: @1" + string(RoomID) + "@0 (@4R@0 TO CHANGE)",1);
 
draw_text_adv(63,46, RoomText,1);

draw_text_adv(2,room_height-28, "@3SPACE: @1S",1);
draw_text_adv(2,room_height-16, "@4L:  @5LOAD",1);



</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>4,4</point>
  </PhysicsShapePoints>
</object>
