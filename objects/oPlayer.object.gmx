<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sSIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-25</depth>
  <persistent>-1</persistent>
  <parentName>oPlatformEntity</parentName>
  <maskName>sMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Platform Variables

initiate();
Complex = 0; // We have 1 collision box
set_collision(0,-7,-31,8,0);
ONTHEGROUND = 0;
InPlace = 0;              
WhiteFade = 0;

alarm[0] = 3; // Redraw MAP

// In game now!

global.InGame = 1;

// Elev Bob Anims

ElevUpTime = 0;
ElevDownTime = 0;

// Normal

xMax = 96/32;
yMax = 240/32;

xAccGround = 8/32;
xAccAir = 8/32;

xDeaccGround = 96/32;
xDeaccAir = 8/32;

Grav = 10/32;

JumpHeight = 192/32;

// Water

xMaxWater = 96/64;
yMaxWater = 240/32;

xAccGroundWater = 8/64;
xAccAirWater = 8/64;

xDeaccGroundWater = 32/64;
xDeaccAirWater = 8/64;

GravWater = 5/32;

JumpHeightWater = 197/32;

// FANFARE

Fanfare = 0;
FanIndex = 0;
FanAlpha = 0;


// Effects

BoostBlend[0] = make_color_rgb(250,10,10);
BoostBlend[1] = make_color_rgb(255,20,10);
BoostBlend[2] = make_color_rgb(255,120,70);

HurtBlend[0] = make_color_rgb(100,20,255);
HurtBlend[1] = make_color_rgb(50,00,255);

Screw = 0;
ang = 0;
imgg = 0;

// Vars

InWater = 0;
InWaterPrev = 0;
InWaterFX = 0;
InWaterPrevFX = 0;

Turning = 0;
Facing = 1;
JustTurned = 0;
JustWall = 0;

AimDirection = 4;
AimTarget = 4;
ForceAim = 0;
Firing = 0;
ForceAimDiag = 0;    
SmoothAim = 0; 
AimSpeed = 2;
ArmFacing = 1;

ChargeTime = 240;
Charge = 0;
ChargeLoop = -1;

Facing = 1;
TrueFacing = 1;

Dash = 0;
DashTime = 39;
DashMax = 40;
DashReq = 140;
DashDivide = 20;
DashGainMax = 2;

ShineDir = 0;

CanAimUp = 0;
Aiming = 0;

Elevator = noone;

HurtPalette = 0;
HurtFlash = 0;
Invincible = 0;

Morphing = 0;
Unmorphing = 0;
KeyDown = 0;
MorphClimb = 0;
PlayBounce = 0;

// Can timers

CantFire = 0;
CanSpace = 0;
RushBoost = 0;
StopIdle = 0;
BallCharge = 0;
CantBall = 0;
CantCharge = 16;
BeamFade = 0;
CanBomb = 0;
JustSpring = 0;
CanStep = 0;

// Draw

TorsoSprite = sBlank;
TorsoIndex = 0;
TorsoX = 0;
TorsoY = 0;

ArmVis = 0;
ArmSprite = sBlank;
ArmX = 0;
ArmY = 0;
ArmAngle = 0;
ChargeX = 0;
ChargeY = 0;

Str[0] = "";
Str[1] = "V";
Str[2] = "G";
Str[3] = "Z";

CType = 0;
CTime = 0;
ChargeIndex = 0;
ChargeSprite = sCharge;

// States

STANDING = 0;
RUNNING = 1;
JUMPING = 2;
DUCKING = 3;
GRIP = 4;
CLIMBING = 5;
WALL = 6;
BALL = 7;
SJSTART = 8;
SUPERJUMP = 9;
SJEND = 10;
CRAWL = 11;
CRAWLING = 12;
UNCRAWL = 13;
IDLE = 14;
BRAKING = 15;
HURT = 16;

State = IDLE;
StatePrev = State;
StateTime = 0;

// Substates

Spinning = 0;
Landing = 0;
SuperBall = 0;

// Sounds

SpinEmitter = audio_emitter_create();
DashEmitter = audio_emitter_create();
ChargeEmitter = audio_emitter_create();
DashSound = -1;
SpinSound = -1;
ShineSound = -1;
CurrentSpin = sndSpin;
BeamSound = -1;

ChargeSound = -1;
ChargeType = sndCharge;

// LISTS

xPrevv = ds_list_create();
yPrevv = ds_list_create();
yVell = ds_list_create();

tPrevv = 0;
for (i=0;i&lt;32;i++)
{
 ds_list_add(xPrevv,x);
 ds_list_add(yPrevv,y);
}





</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if audio_is_playing(SpinSound)
 audio_stop_sound(SpinSound);
if audio_is_playing(DashSound)
 audio_stop_sound(DashSound);
if audio_is_playing(ShineSound)
 audio_stop_sound(ShineSound);
if audio_is_playing(ChargeLoop)
 audio_stop_sound(ChargeLoop);
 
audio_emitter_free(SpinEmitter);
audio_emitter_free(DashEmitter);
audio_emitter_free(ChargeEmitter);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Redraw Minimap

with (oControl) hud_map_redraw();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if global.PausedGame exit;

StatePrev = State;

if PlayBounce PlayBounce --;

ds_list_insert(xPrevv,0,x);
ds_list_insert(yPrevv,0,y);
ds_list_insert(yVell,0,yVel);

Dir = point_direction(x,y,xprevious,yprevious);

if ds_list_size(xPrevv) &gt; 32
{
 ds_list_delete(xPrevv,32);
 ds_list_delete(yPrevv,32);
 ds_list_delete(yVell,32);
}

InWater = place_meeting(x,y,oLiquid);
if global.Power[P_GSUIT] InWater = 0;
InWaterFX = instance_place(x,y,oLiquid);


if InWaterFX &amp;&amp; !InWaterPrevFX
{ 
 Splash = instance_create(x,InWaterFX.y,oSplash);
 Object = InWaterFX.object_index;
 Splash.Creator = InWaterFX; 
 if Object == oWater or Object == oPuddle
  Splash.sprite_index = sWaterSplash; 
  
 if on_ground(0,1) or yVel == 0
 {
  if Object == oAcid
   Splash.sprite_index = sAcidSplash3; 
  if Object == oWater or Object == oPuddle
   Splash.sprite_index = sWaterSplash3;
  sound_play_pos(sndSplashGround,x,y);
 }
 else
 sound_play_pos(sndSplash,x,y);
 
 
}
if !InWaterFX &amp;&amp; InWaterPrevFX
{ 
 Object = InWaterPrevFX.object_index;

 Splash = instance_create(x,InWaterPrevFX.y,oSplash);
 Splash.Creator = InWaterPrevFX;
 
 if Object == oAcid
  Splash.sprite_index = sAcidSplash2; 
 if Object == oWater or Object == oPuddle
  Splash.sprite_index = sWaterSplash2; 
  
 if on_ground(0,1) or yVel == 0
 {
  if Object == oAcid
   Splash.sprite_index = sAcidSplash3; 
  if Object == oWater or Object == oPuddle
   Splash.sprite_index = sWaterSplash3;
  sound_play_pos(sndSplashGround,x,y);
 }
 else
 sound_play_pos(sndSplash,x,y);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
InWaterPrev = place_meeting(x,y,oLiquid);
InWaterPrevFX = instance_place(x,y,oLiquid);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// INPUT
 
MoveTick += 1;

if global.PausedGame
{
 if Turning
  image_index -= image_speed;
  else
  image_speed = 0; 

 if !audio_is_paused(SpinSound)  
 audio_pause_sound(SpinSound);
 if !audio_is_paused(DashSound)  
 audio_pause_sound(DashSound);
 if !audio_is_paused(ChargeLoop)  
 audio_pause_sound(ChargeLoop);
 if !audio_is_paused(ShineSound)  
 audio_pause_sound(ShineSound); 
 if !audio_is_paused(ChargeSound)  
 audio_pause_sound(ChargeSound); 
 
 exit; 
}
else
{
 audio_emitter_gain(SpinEmitter,global.SoundVol);
 audio_emitter_gain(ChargeEmitter,global.SoundVol); 
 audio_emitter_gain(DashEmitter,global.SoundVol);
 if audio_is_paused(ShineSound)  
 audio_resume_sound(ShineSound);
 if audio_is_paused(DashSound)  
 audio_resume_sound(DashSound);
 if audio_is_paused(SpinSound)   
 audio_resume_sound(SpinSound);
 if audio_is_paused(ChargeLoop)   
 audio_resume_sound(ChargeLoop);  
 if audio_is_paused(ChargeSound)   
 audio_resume_sound(ChargeSound);   
}

on_ground_prev = on_ground(0,1);
Shining = (State == SUPERJUMP or State == SJEND or State == SJSTART);
collision_bounds(0);
OnMoving = (collision_line(round(lb),round(bb+1-1),round(rb-1),round(bb+1-1),oMovingSolid,1,1));

if State == GRIP &amp;&amp; place_meeting(x+12*Facing,y-26,oBreakFall)
with instance_place(x+12*Facing,y-26,oBreakFall) event_user(0);

if InWater Charge = 0;
 
if JustWall JustWall--;
if CanStep CanStep--;
if CanAimUp CanAimUp--;
if ForceAim ForceAim--;
if Charge Charge --;
if HurtFlash HurtFlash--;
if BallCharge BallCharge--;
if CantBall CantBall--;
if RushBoost RushBoost--;
if CanSpace CanSpace--;
if JustSpring JustSpring--;
if CanBomb CanBomb--;
if CantFire CantFire--;
if CantCharge CantCharge--;
if BeamFade BeamFade--;
if Invincible Invincible--;
if ElevDownTime ElevDownTime--;
if ElevUpTime ElevUpTime--;

if Fanfare Fanfare--;

if Fanfare &gt; 30
{
 FanAlpha += 1/24;
}

if Fanfare &lt; 160 &amp;&amp; Fanfare &gt; 0
 FanAlpha -= 1/2;
 
if Fanfare &lt; 220
 FanIndex += 1/4;
 if FanIndex &gt; 3
  FanIndex = 3;

if Fanfare == 1
{
 oSound.alarm[0] = 55;
 FanAlpha = 0;
}

if global.Suit == 3
 Charge = 0;


if global.Power[P_HIJUMP]// &amp;&amp; global.Suit != 3
{
 JumpHeight = 248/32;
 JumpHeightWater = 253/32; 
}
else
{
 JumpHeight = 192/32;
 JumpHeightWater = 197/32;
}


// Audio

/*audio_emitter_position(SpinEmitter,x,y-10,0);
audio_emitter_position(DashEmitter,x,y-10,0);
audio_emitter_position(ChargeEmitter,x+ChargeX,y+ChargeY,0);   */

audio_emitter_position(SpinEmitter,0,0,0);
audio_emitter_position(DashEmitter,0,0,0);
audio_emitter_position(ChargeEmitter,0,0,0);

if Spinning &amp;&amp; StateTime &gt; 3
{
 if !InWater
 {
  TargetSound = sndSpin;
  if global.Power[P_SPACE] TargetSound = sndSpace;
  if global.Power[P_SCREW] TargetSound = sndScrew;
  if global.Suit == 3 TargetSound = sndSpinZero;
  if InWater TargetSound = sndSpinWater;
  
  if CurrentSpin != TargetSound or !audio_is_playing(SpinSound)
  {
   audio_stop_sound(SpinSound);           
   
   SpinSound = audio_play_sound_on(SpinEmitter,TargetSound,1,1); 
   CurrentSpin = TargetSound;
  }
 }
 else
 {   
  if CurrentSpin == sndSpin or CurrentSpin == sndSpinZero or CurrentSpin == sndScrew or CurrentSpin == sndSpace audio_stop_sound(SpinSound);
  if !audio_is_playing(SpinSound)
  SpinSound = audio_play_sound_on(SpinEmitter,sndSpinWater,1,1);
  CurrentSpin = sndSpinWater
 } 
}
else
{
 if audio_is_playing(SpinSound)
  audio_stop_sound(SpinSound);
 TargetSound = sndGrip;
}
 
if Charge &gt; 0 
{
 if !audio_is_playing(ChargeLoop)
  ChargeLoop = audio_play_sound_on(DashEmitter,sndChargeLoop,1,1); 
}
else
if audio_is_playing(ChargeLoop)
 audio_stop_sound(ChargeLoop);
 
if State == SUPERJUMP
{
 if !audio_is_playing(ShineSound)
  ShineSound = audio_play_sound_on(DashEmitter,sndShineLoop,1,1); 
}
else
if audio_is_playing(ShineSound)
 audio_stop_sound(ShineSound);
 
 
if Dash == 1
{
 DashSound = audio_play_sound_on(DashEmitter,sndDashStart,0,1); 
}

if Dash &gt;= 1
{
 if audio_get_type(DashSound) == sndDashStart &amp;&amp; !audio_is_playing(DashSound)
  DashSound = audio_play_sound_on(DashEmitter,sndDashLoop,1,1);  
}
else
{
 audio_stop_sound(DashSound);
}


// DASH CONTROL

if State == RUNNING
{
 if StateTime &gt; DashReq
  Dash += 1;
  else
  Dash = 0;
}
else
if Dash &lt; DashMax
 Dash = 0;
 
if abs(xVel) &lt; 1 or x == ds_list_find_value(xPrevv,2) or InWater or global.Power[P_SPEEDBOOSTER] == 0
{
 if State == RUNNING
 {
  StateTime = 0;
 }
 Dash = 0;
}

if Dash &gt;= DashTime &amp;&amp; State == RUNNING &amp;&amp; abs(xVel) &gt; 0
{
 if (Facing == -1 &amp;&amp; !global.KeyPushed[0,KEY_LEFT])
 or (Facing == 1 &amp;&amp; !global.KeyPushed[0,KEY_RIGHT])
 {
  image_index = 0;
  State = BRAKING;
  StateTime = 0;
  Dash = 0;
  sound_play_pos(sndBrake,x,y);
 } 
}

if State == BRAKING
{
 Turning = 0;
 if !on_ground(0,1) State = JUMPING;
 else
 if StateTime &gt; 1
 {
  if (xVel &lt; 0 &amp;&amp; collision_left_wall(0,1))
  or (xVel &gt; 0 &amp;&amp; collision_right_wall(0,1))
  {
   State = STANDING;
   xVel = 0;
   StateTime = 0;
  }
  else
  if !(Facing == -1 &amp;&amp; global.KeyPushed[0,KEY_LEFT])
  &amp;&amp; !(Facing == 1 &amp;&amp; global.KeyPushed[0,KEY_RIGHT])
  if !(Facing == 1 &amp;&amp; global.KeyPushed[0,KEY_LEFT])
  &amp;&amp; !(Facing == -1 &amp;&amp; global.KeyPushed[0,KEY_RIGHT])  
  if global.KeyPushed[0,KEY_DOWN]
  {
   Charge = ChargeTime;
   State = DUCKING;
   StateTime = 0;
   xVel = 0;
   instance_create(x,y,oSpeedSplash);
   CantBall = 2;
  } 
 }
}

if State == BALL &amp;&amp; on_ground(0,1) &amp;&amp; Dash &gt;= DashTime
 BallCharge = 5;
 
if global.KeyPushed[0,KEY_DOWN] &amp;&amp; State == BALL &amp;&amp; StateTime &gt; 1 &amp;&amp; !global.KeyPushed[0,KEY_LEFT]
&amp;&amp; !global.KeyPushed[0,KEY_RIGHT] &amp;&amp; BallCharge &gt; 0 &amp;&amp; on_ground(0,1) &amp;&amp; Dash &gt;= DashTime
{
 Charge = ChargeTime;
 StateTime = 0;
 xVel = 0;
 instance_create(x,y,oSpeedSplash);
 Dash = 0;
}

if global.Suit == 3 
{
 Dash = 0;
 if State == BRAKING
  State = STANDING;
}

if Dash &gt; DashMax Dash = DashMax;
 
 
 
 
  
// MOVE LEFT AND RIGHT


if global.CanControl &amp;&amp; State != WALL &amp;&amp; State != DUCKING &amp;&amp; State != BRAKING &amp;&amp; !Shining &amp;&amp; !(State == BALL &amp;&amp; yVel &lt; 0) &amp;&amp; State != HURT
{
 // NOT IN WATER
 if !InWater
 {
  // WALK LEFT 
 
  if (global.KeyPushed[0,KEY_LEFT] &amp;&amp; !global.KeyPushed[0,KEY_RIGHT]) or (Spinning &amp;&amp; Facing == -1)
  {
   if on_ground(0,1)
   {
    if xVel &gt; - xMax
     xVel -= xAccGround; 
   }
   else
   {
    if !(Spinning &amp;&amp; Facing == -1 &amp;&amp; collision_right(0,1)) or JustWall
    {
     if xVel &gt; - xMax
      xVel -= xAccAir; 
    }
    else
    {
     if InWater == 0
     {
      if xVel &gt; - xMax
       xVel -= 1/32; 
     }
     else
     {
      if xVel &gt; - xMax
       xVel -= 1/32; 
     }     
    }    
   } 
  }
 
  // WALK RIGHT 
 
  if (global.KeyPushed[0,KEY_RIGHT] &amp;&amp; !global.KeyPushed[0,KEY_LEFT]) or (Spinning &amp;&amp; Facing == 1)
  {
   if on_ground(0,1)
   {
    if xVel &lt; xMax
     xVel += xAccGround; 
   }
   else
   {
    if !(Spinning &amp;&amp; Facing == 1 &amp;&amp; collision_left(0,1)) or JustWall   
    {
     if xVel &lt; xMax
      xVel += xAccAir; 
    }
    else
    {
     if InWater == 0
     {
      if xVel &lt; xMax
       xVel += 1/32; 
     }
     else
     {
      if xVel &lt; xMax
       xVel += 1/32; 
     }     
    }    
   } 
  } 
 }
 else
 {
  // WALK LEFT 
 
  if (global.KeyPushed[0,KEY_LEFT] &amp;&amp; !global.KeyPushed[0,KEY_RIGHT]) or (Spinning &amp;&amp; Facing == -1)
  {
   if on_ground(0,1)
   {
    if xVel &gt; - xMaxWater
     xVel -= xAccGroundWater; 
   }
   else
   {
    if !(Spinning &amp;&amp; Facing == -1 &amp;&amp; collision_right(0,1)) or JustWall
    {
     if xVel &gt; - xMaxWater
      xVel -= xAccAirWater; 
    }
    else
    {
     if xVel &gt; - xMaxWater
      xVel -= 1/32; 
    }
   } 
  }
 
  // WALK RIGHT 
 
  if (global.KeyPushed[0,KEY_RIGHT] &amp;&amp; !global.KeyPushed[0,KEY_LEFT]) or (Spinning &amp;&amp; Facing == 1)
  {
   if on_ground(0,1)
   {
    if xVel &lt; xMaxWater
     xVel += xAccGroundWater; 
   }
   else
   {
    if !(Spinning &amp;&amp; Facing == 1 &amp;&amp; collision_left(0,1))  or JustWall  
    {
     if xVel &lt; xMaxWater
      xVel += xAccAirWater; 
    }
    else
    {
     if xVel &lt; xMaxWater
      xVel += 1/32; 
    }  
   } 
  } 
 }
}

if (State == BALL &amp;&amp; yVel &lt; 0)
{
 if (State == BALL &amp;&amp; yVel &lt; 0)
 {
  if xVel &gt; 0 
  if (xVel &lt; xMaxWater &amp;&amp; InWater) or (xVel &lt; 1.5 &amp;&amp; !InWater)
  xVel += 8/32;
  if xVel &lt; 0 
  if (xVel &gt; -xMaxWater &amp;&amp; InWater) or (xVel &gt; -1.5 &amp;&amp; !InWater)
  xVel -= 8/32;
  
  if xVel == 0 &amp;&amp; global.CanControl
  {
   if global.KeyPushed[0,KEY_LEFT]
    xVel = -8/32;
   if global.KeyPushed[0,KEY_RIGHT]
    xVel += 8/32;
  }
 }
 
 if xVel &gt; 0 
 if (xVel &lt; xMaxWater &amp;&amp; InWater) or (xVel &lt; 1.5 &amp;&amp; !InWater)
 xVel += 8/32;
 
 if xVel &lt; 0 
 if (xVel &gt; -xMaxWater &amp;&amp; InWater) or (xVel &gt; -1.5 &amp;&amp; !InWater)
 xVel -= 8/32;
 
 if xVel == 0 &amp;&amp; global.CanControl
 {
  if global.KeyPushed[0,KEY_LEFT]
   xVel = -8/32;
  if global.KeyPushed[0,KEY_RIGHT]
   xVel += 8/32;
 }
}

// DECELERATE

if (!((global.KeyPushed[0,KEY_RIGHT] &amp;&amp; xVel &gt; 0) or (global.KeyPushed[0,KEY_LEFT] &amp;&amp; xVel &lt; 0)) or !(global.KeyPushed[0,KEY_LEFT] xor global.KeyPushed[0,KEY_RIGHT]) or !global.CanControl or State == BRAKING) &amp;&amp; !Shining
if !Spinning &amp;&amp; !(State == BALL &amp;&amp; yVel &lt; 0) &amp;&amp; State != HURT
{
 if !InWater
 {
  if on_ground(0,1) or !global.CanControl
  {
   if xVel &gt; 0
    xVel = max(xVel - xDeaccGround,0);
   if xVel &lt; 0
    xVel = min(xVel + xDeaccGround,0);
  }  
  else
  {
   if xVel &gt; 0
    xVel = max(xVel - xDeaccAir,0);
   if xVel &lt; 0
    xVel = min(xVel + xDeaccAir,0);
  }   
 }
 else
 {
  if on_ground(0,1) or !global.CanControl
  {
   if xVel &gt; 0
    xVel = max(xVel - xDeaccGroundWater,0);
   if xVel &lt; 0
    xVel = min(xVel + xDeaccGroundWater,0);
  }  
  else
  {
   if xVel &gt; 0
    xVel = max(xVel - xDeaccAirWater,0);
   if xVel &lt; 0
    xVel = min(xVel + xDeaccAirWater,0);
  }   
 }
}

// GRAVITY

if !on_ground(0,1) &amp;&amp; State != CLIMBING &amp;&amp; State != GRIP &amp;&amp; !Shining
{
 if !InWater
  yVel += Grav;
  else
  yVel += GravWater;  
}
else
if yVel &gt; 0 yVel = 0;

if !Shining
{
 if !InWater
 { 
  if yVel &gt; yMax
   yVel = yMax;
  if xVel &gt; xMax
   xVel = xMax;
  if xVel &lt; -xMax
   xVel = -xMax;
 } 
 else
 { 
  if yVel &gt; yMaxWater
   yVel = yMaxWater;
  if xVel &gt; xMaxWater
   xVel = xMaxWater;
  if xVel &lt; -xMaxWater
   xVel = -xMaxWater;
 } 
}

if State == JUMPING or (State == BALL &amp;&amp; !on_ground(0,1))
{
 xMax = 2;
 xMaxWater = 1;
 if Spinning &amp;&amp; State != BALL
 {
  xAccAir = 8/32;
  xAccAirWater = 8/128;
  
  if Facing == 1 &amp;&amp; xVel &lt; 0 xVel = 0;
  if Facing == -1 &amp;&amp; xVel &gt; 0 xVel = 0;
 }
  else
 {
  xAccAir = (8/32);
  xAccAirWater = (8/128);
 }
}
else
{
 xMax = 3;
 xMaxWater = 1.5;
}


if JustSpring xVel = 0;

if State == CRAWLING 
{
 xMax = 1;
 xMaxWater = 1;
 if Turning xVel = 0;
 xAccGround = 4/32;
 xDeaccGround = 4/32;
}
else
{
 xAccGround = 8/32;
 xDeaccGround = 96/32;
}
if State == BRAKING
{
 xDeaccGround = (10/32) * (StateTime&gt;8);
}

break_blocks();

xMaxx = xMax;
xMax += Dash/DashDivide;
if xMax - xMaxx &gt; DashGainMax
 xMax = xMaxx + DashGainMax;

if State == JUMPING &amp;&amp; yVel &lt; 0 &amp;&amp; !global.KeyPushed[0,KEY_A] 
{
 yVel = 10/32;
} 

if RushBoost xVel = 5*Facing;
// FLOOR VEL

if on_ground(0,1) &amp;&amp; yVel &gt;= -.6
{  
 yVel = 0;
}
// PLATFORM

if global.CanControl
if on_platform(0,1) &amp;&amp; yVel == 0 &amp;&amp; global.KeyPressed[0,KEY_A] &amp;&amp; global.KeyPushed[0,KEY_DOWN]
{
 y += 3; 
 yVel = .25;
}

// JUMP UP


//space
if global.CanControl
if global.Power[P_SPACE] &amp;&amp; global.Suit != 3 &amp;&amp; !InWater
if global.KeyPressed[0,KEY_A] &amp;&amp; Spinning &amp;&amp; State == JUMPING
if yVel &gt;= 70/32 &amp;&amp; !CanSpace
{
 CanSpace = 16;
 
 yVel = -JumpHeight;
 
 MoveTick = 1;
 yMP = 0;
 yMN = 0;
}

// springball

if global.CanControl &amp;&amp; State == BALL &amp;&amp; (((global.KeyPushed[0,KEY_A] &amp;&amp; !collision_top(0,9)) or (global.KeyPressed[0,KEY_A] &amp;&amp; collision_top(0,9))) or JustSpring == 1) &amp;&amp; on_ground(0,1)
if global.Power[P_SPRINGBALL] &amp;&amp; (StateTime &gt; 3 or JustSpring == 1)
if !(State == BALL &amp;&amp; global.Power[P_SPRINGBALL] &amp;&amp; xVel == 0 &amp;&amp; !(global.KeyPushed[0,KEY_LEFT] xor global.KeyPushed[0,KEY_RIGHT]) &amp;&amp; Charge &gt; 0)
{
 if !InWater
  yVel = -JumpHeight;
  else
  yVel = -JumpHeightWater;
 
 MoveTick = 1;
 yMP = 0;
 yMN = 0;
 image_index = 1;

 sound_play_pos(sndBounceDelay,x,y);
}

if global.CanControl
if !((!Turning &amp;&amp; (Charge &gt; 0) &amp;&amp; global.KeyPressed[0,KEY_A] &amp;&amp; (State == STANDING or State == DUCKING or (State == JUMPING &amp;&amp; !Spinning) 
or (State == BALL &amp;&amp; global.Power[P_SPRINGBALL] &amp;&amp; xVel == 0 &amp;&amp; !(global.KeyPushed[0,KEY_LEFT] xor global.KeyPushed[0,KEY_RIGHT])))) &amp;&amp; !(on_ground(0,1) &amp;&amp; collision_top(0,5)))
{
 if on_ground(0,1) &amp;&amp; yVel == 0 &amp;&amp; global.KeyPressed[0,KEY_A]
 if State == STANDING or State == DUCKING or State == RUNNING
 {
  if !InWater
   yVel = -JumpHeight;
   else
   yVel = -JumpHeightWater;
  
  MoveTick = 1;
  yMP = 0;
  yMN = 0;
  image_index = 0;
  
  if global.KeyPushed[0,KEY_RIGHT] xor global.KeyPushed[0,KEY_LEFT]
  {
   Spinning = 1;
  }
  else
  {
   if !InWater
   {
    if !global.Power[P_HIJUMP]
     sound_play_pos(sndJump,x,y);
     else
     sound_play_pos(sndHijump,x,y);     
   }
    else
    sound_play_pos(sndJumpWater,x,y);
  }
  
  State = JUMPING;
  Turning = 0;
  Landing = 0;
 }
}
else
if !(State == BALL &amp;&amp; !on_ground(0,1))
{
 SuperBall = (State == BALL &amp;&amp; global.Power[P_SPRINGBALL])
 StateTime = 0;
 State = SJSTART;
 Charge = 0;
 image_speed = 0;
}

if State != JUMPING
 Spinning = 0;

 // WALLJUMP

yy = y;
y += 24;
Below = collision_left(0,1);
y -= 24;
Above = collision_left(0,1);
y = yy;

if !(global.Power[P_SPACE] &amp;&amp; global.Suit != 3 &amp;&amp; !InWater)
{
 if global.KeyPushed[0,KEY_RIGHT] &amp;&amp; global.KeyPressed[0,KEY_A] &amp;&amp; collision_left(0,1) &amp;&amp; State == JUMPING &amp;&amp; Spinning &amp;&amp; yVel &gt;= 0 &amp;&amp; Below// &amp;&amp; Above
 if !collision_bottom(0,10) 
 {
  State = WALL;
  image_index = 0;
  if !InWater
  {
   if global.Suit != 3
    sound_play_pos(sndWall,x,y);
    else
    sound_play_pos(sndWallZero,x,y);   
  }
  else
  sound_play_pos(sndJumpWater,x,y);
  Facing = 1;
  Spinning = 0;
  Turning = 0;
  xVel = 0;
  yVel = 0;
 }
 
 yy = y;
 y += 24;
 Below = collision_right(0,1);
 y -= 24;
 Above = collision_right(0,1);
 y = yy;
 
 if global.KeyPushed[0,KEY_LEFT] &amp;&amp; global.KeyPressed[0,KEY_A] &amp;&amp; collision_right(0,1) &amp;&amp; State == JUMPING &amp;&amp; Spinning &amp;&amp; yVel &gt;= 0 &amp;&amp; Below// &amp;&amp; Above 
 if !collision_bottom(0,10)
 {
  State = WALL;
  image_index = 0;
  if !InWater
  {
   if global.Suit != 3
    sound_play_pos(sndWall,x,y);
    else
    sound_play_pos(sndWallZero,x,y);   
  }
  else
  sound_play_pos(sndJumpWater,x,y);
  Facing = -1;
  Spinning = 0;
  Turning = 0;
  xVel = 0;
  yVel = 0;
 }
}


if !Spinning &amp;&amp; State == JUMPING &amp;&amp; yVel &gt;= 0 &amp;&amp; global.KeyPressed[0,KEY_A]
{
 Spinning = 1;
 xVel = Facing;
 image_index = 0;
 if AimDirection == 0
  image_index = 2;
 StateTime = 0;
} 

// LOWER XVEL WHEN IN WALL

if collision_right_wall(0,1) &amp;&amp; xVel &gt; 0
 xVel *= 0;
 
if collision_left_wall(0,1) &amp;&amp; xVel &lt; 0
 xVel *= 0;
 
// FACING
if State == BRAKING
{
 Turning = 0;
 Landing = 0;
 Firing = 0;
}
if global.CanControl &amp;&amp; State != CLIMBING &amp;&amp; State != WALL &amp;&amp; !Morphing &amp;&amp; !Unmorphing &amp;&amp; State != CRAWL &amp;&amp; State != UNCRAWL &amp;&amp; State != IDLE &amp;&amp; State != BRAKING &amp;&amp; !Shining &amp;&amp; State != HURT
if !(Facing == 1 &amp;&amp; xVel &gt; 0 &amp;&amp; State == BALL &amp;&amp; yVel &lt; 0)
if !(Facing == -1 &amp;&amp; xVel &lt; 0 &amp;&amp; State == BALL &amp;&amp; yVel &lt; 0)
if !Turning
{
 if (global.KeyPushed[0,KEY_RIGHT] &amp;&amp; !global.KeyPushed[0,KEY_LEFT] &amp;&amp; State != GRIP)
 or (global.KeyPressed[0,KEY_RIGHT] &amp;&amp; !global.KeyPushed[0,KEY_LEFT] &amp;&amp; State == GRIP &amp;&amp; !global.KeyPushed[0,KEY_UP] &amp;&amp; !global.KeyPushed[0,KEY_DOWN] &amp;&amp; !global.KeyPushed[0,KEY_POWER])
 {
  if Facing == -1 &amp;&amp; !Spinning &amp;&amp; !Turning
  {
   if State != BALL
   Turning = 1;
   image_index = 0;  
   if State == BALL image_index = 1;
   if State == GRIP &amp;&amp; Facing != TrueFacing AimTarget = 4;
  }
  Facing = 1; 
  Firing = 0;
 }
 if (global.KeyPushed[0,KEY_LEFT] &amp;&amp; !global.KeyPushed[0,KEY_RIGHT] &amp;&amp; State != GRIP)
 or (global.KeyPressed[0,KEY_LEFT] &amp;&amp; !global.KeyPushed[0,KEY_RIGHT] &amp;&amp; State == GRIP &amp;&amp; !global.KeyPushed[0,KEY_UP] &amp;&amp; !global.KeyPushed[0,KEY_DOWN] &amp;&amp; !global.KeyPushed[0,KEY_POWER])
 {
  if Facing == 1 &amp;&amp; !Spinning &amp;&amp; !Turning
  {
   if State != BALL
   Turning = 1;
   image_index = 0;
   if State == BALL image_index = 1;
   if State == GRIP &amp;&amp; Facing != TrueFacing AimTarget = 4;
  }
  Facing = -1; 
  Firing = 0;
 }
}

if Turning &amp;&amp; ((State == STANDING or State == RUNNING) or (State == JUMPING &amp;&amp; image_index &lt;= 0))
 xVel = 0;

if !(State == BALL &amp;&amp; yVel &lt; 0) &amp;&amp; State != HURT
{
 if Facing == 1 &amp;&amp; xVel &lt; 0 xVel = 0;
 if Facing == -1 &amp;&amp; xVel &gt; 0 xVel = 0; 
}

if State == IDLE xVel = 0;
// STATE CONTROL

JustJumped = 0;

if State == STANDING or State == RUNNING or State == JUMPING
{
 if on_ground(0,1) &amp;&amp; yVel == 0
 {
  if State == JUMPING // LAND
  {
   if (xVel == 0 or (Facing == 1 &amp;&amp; collision_right_wall(0,1)) or (Facing == -1 &amp;&amp; collision_left_wall(0,1))) 
   &amp;&amp; !((global.KeyPushed[0,KEY_RIGHT] xor global.KeyPushed[0,KEY_LEFT]) &amp;&amp; !((Facing == 1 &amp;&amp; collision_right_wall(0,1)) or (Facing == -1 &amp;&amp; collision_left_wall(0,1))))
    Landing = 1;
   xVel = 0;
   State = STANDING;
   JustJumped = 1;
   image_index = 0; 
   Turning = 0;
   if AimDirection == 0 &amp;&amp; !Spinning
    ForceAimDiag = 1;
   Spinning = 0; 
   if !InWater
   {
    if global.Suit != 3
    {
     if !place_meeting(x,y,oSplashArea)
      sound_play_pos(sndLand,x,y);
      else
      {
       sound_play_pos(sndLandWetZero,x,y);   
       Sp = instance_create(x, y, oSplash);
       Sp . sprite_index = sWaterSplash3;
       Sp . Creator = Sp;   
      }    
    }
     else
     {     
      if !place_meeting(x,y,oSplashArea)
       sound_play_pos(sndLandZero,x,y);
       else
       {
        sound_play_pos(sndLandWetZero,x,y);   
        Sp = instance_create(x, y, oSplash);
        Sp . sprite_index = sWaterSplash3;
        Sp . Creator = Sp;   
       }    
     }   
   }
   else
   {
    sound_play_pos(sndLandWater,x,y);
   }
  }
  
  if !(abs(xVel)&gt;0 or (global.KeyPushed[0,KEY_RIGHT] xor global.KeyPushed[0,KEY_LEFT])) or global.CanControl == 0 or JustJumped
   State = STANDING;
   else
   State = RUNNING;   
 }
 else
 {
  if State == RUNNING &amp;&amp; !Spinning
   image_index = 0;
  State = JUMPING;
 }
}

// CRAWL

if global.Suit == 3
{
 if position_meeting(x+Facing*8,y-18,oSolid) &amp;&amp; !position_meeting(x+Facing*8,y-5,oSolid) &amp;&amp; !Turning
 {
  if (Facing == 1 &amp;&amp; global.KeyPushed[0,KEY_RIGHT]) or (Facing == -1 &amp;&amp; global.KeyPushed[0,KEY_LEFT])
  if State == RUNNING or State == DUCKING or State == STANDING
  {
   State = CRAWL;
   image_index = 0;
   xVel = 0;
//   sound_play_pos(sndCrawlDown,x,y);
  } 
 }
}

if State == CRAWLING &amp;&amp; !collision_top(0,16) &amp;&amp; !Turning
{
 State = UNCRAWL;
 image_index = 0;
 xVel = 0;
}

// CRAWCH

CanElevator = (State == STANDING &amp;&amp; place_meeting(x,y+2,oElevator) &amp;&amp; !Turning &amp;&amp; global.KeyPressed[0,KEY_DOWN] &amp;&amp; !global.KeyPushed[0,KEY_UP] &amp;&amp; AimDirection == 4);
CanElevatorUp = (State == STANDING &amp;&amp; place_meeting(x,y+2,oElevator) &amp;&amp; !Turning &amp;&amp; !global.KeyPushed[0,KEY_DOWN] &amp;&amp; global.KeyPressed[0,KEY_UP] &amp;&amp; AimDirection == 4);

if CanElevator &amp;&amp; instance_place(x,y+2,oElevator).Direction == 0
&amp;&amp; abs(instance_place(x,y+2,oElevator).x-x)&lt;7
{
 Elevator = instance_place(x,y+2,oElevator);
 x = Elevator.x;
 y = Elevator.y;
 Turning = 1;
 StopIdle = 0;
 image_index = 0;
 State = IDLE;
 Elevator.Active = 1;
 Elevator.yVel = 2;
 Landing = 0;
 Elevator.CantStop = 4;
}
else
if CanElevatorUp &amp;&amp; instance_place(x,y+2,oElevator).Direction == 1
&amp;&amp; abs(instance_place(x,y+2,oElevator).x-x)&lt;7
{
 Elevator = instance_place(x,y+2,oElevator);
 x = Elevator.x;
 y = Elevator.y;
 Turning = 1;
 StopIdle = 0;
 image_index = 0;
 State = IDLE;
 Elevator.Active = 1;
 Elevator.yVel = -2;
 Landing = 0;
 Elevator.CantStop = 4;
}
else
if State == STANDING &amp;&amp; global.KeyPressed[0,KEY_DOWN] &amp;&amp; !global.KeyPushed[0,KEY_UP] &amp;&amp; !(global.KeyPushed[0,KEY_POWER] &amp;&amp; AimDirection == 6)
{
 State = DUCKING;
 if global.Suit != 3
  sound_play_pos(sndCrouch,x,y);
}
else
if State == DUCKING &amp;&amp; global.KeyPressed[0,KEY_DOWN] &amp;&amp; !global.KeyPushed[0,KEY_UP] &amp;&amp; global.Suit != 3 &amp;&amp; !(global.KeyPushed[0,KEY_POWER] &amp;&amp; AimDirection == 6) &amp;&amp; global.Power[P_MORPHBALL] &amp;&amp; !CantBall// BALL
{
 Morphing = 1;
 image_index = 0;
 State = BALL;
 BallAngle = 0;
 sound_play_pos(sndMorph,x,y);
}

if State == JUMPING &amp;&amp; global.KeyPressed[0,KEY_DOWN] &amp;&amp; !global.KeyPushed[0,KEY_UP] &amp;&amp; KeyDown &gt; 0 &amp;&amp; global.Suit != 3 &amp;&amp; !(global.KeyPushed[0,KEY_POWER] &amp;&amp; AimDirection == 6) &amp;&amp; global.Power[P_MORPHBALL]// BALL
{
 image_index = 1;
 State = BALL;
 BallAngle = 0;
 sound_play_pos(sndMorph,x,y);
 xVel = 0;
 yVel = 0;
}

if global.KeyPressed[0,KEY_DOWN] KeyDown = 15;
if global.KeyPressed[0,KEY_UP] KeyDown = 0;
if KeyDown KeyDown--;


if State == DUCKING or State == CRAWL or State == UNCRAWL
{
 xVel = 0;
 yVel = 0;
 if !on_ground(0,1)
  State = JUMPING;
}
if State == CRAWLING  if !on_ground(0,5) if !collision_top(0,8)
  State = JUMPING;

if State == DUCKING &amp;&amp; global.KeyPressed[0,KEY_UP] &amp;&amp; !global.KeyPushed[0,KEY_DOWN] &amp;&amp; !collision_top(0,8) &amp;&amp; !(global.KeyPushed[0,KEY_POWER] &amp;&amp; AimDirection == 2)
{
 State = STANDING;
 CanAimUp = 7;
}
else
// Unmorph
if State == BALL &amp;&amp; global.KeyPressed[0,KEY_UP] &amp;&amp; !global.KeyPushed[0,KEY_DOWN]
{
 if on_ground(0,1) 
 {
  if !collision_top(0,10) &amp;&amp; !collision_top(0,8) &amp;&amp; !collision_top(0,16)
  {
   sound_play_pos(sndUnmorph,x,y);
   State = DUCKING;
   Unmorphing = 1;
   image_index = 0; 
   global.KeyPushed[0,KEY_RIGHT] = 0;
   global.KeyPushed[0,KEY_LEFT] = 0;
   xVel = 0;
   WhiteFade = 1;
  }
 }
 else
 if !collision_top(0,14)
 {
  xVel = 0;
  yVel = 0;
  sound_play_pos(sndUnmorph,x,y);
  State = JUMPING;
   WhiteFade = 1;
 }
}

if State == DUCKING &amp;&amp; ((global.KeyPushed[0,KEY_RIGHT] &gt; 10 &amp;&amp; Facing == 1) or (global.KeyPushed[0,KEY_LEFT] &gt; 10 &amp;&amp; Facing == -1)) &amp;&amp; !collision_top(0,8)
{
 State = STANDING;
}


// GRIP

with (oBreakable)
{
 y = ystart;
 if !(Holding &amp;&amp; Index &lt; 2)
 if Dying or Respawning
 or Dont
  y = ystart - 10000;
}

if place_meeting(x+10*Facing,y-32,oBreakable) &amp;&amp; (State == GRIP)
with instance_place(x+10*Facing,y-32,oBreakable)
  {
   Index = .25;
   Dying = 1;
   DeathTime = RespawnTime;
   Dont = 2;
   y -= 100000;
  }
for (i=-10;i&lt;10;i+=5)
if place_meeting(x+6*Facing,y-12+i,oBreakable) &amp;&amp; (State == CLIMBING)
with instance_place(x+6*Facing,y-12+i,oBreakable)
  {
   Index = .25;
   Dying = 1;
   DeathTime = RespawnTime;
   Dont = 2;
   y -= 100000;
  }
  
if State == JUMPING &amp;&amp; !Turning &amp;&amp; global.CanControl &amp;&amp; yVel &gt; 0 &amp;&amp; global.Power[P_GRIP]
if !place_meeting(x,y-4,oSolid) &amp;&amp; !place_meeting(x,y+8,oSolid) &amp;&amp; !place_meeting(x,y+19,oSolid)
{
 if global.KeyPushed[0,KEY_RIGHT]
 if position_meeting(x+8,y-26,oSolid) &amp;&amp; !position_meeting(x+8,y-32,oSolid) &amp;&amp; place_meeting(x+1,y,oSolid) &amp;&amp; Facing == 1
 {
  y += 1;
  move_snap(1,16)
  y -= 5;
  
  repeat (10) 
  {
   if !place_meeting(x+1,y,oSolid)
   {
    x ++;
    collision_bounds(0);
   }
  }
  
  State = GRIP; 
  TrueFacing = 1;
  Facing = 1;
  
  if global.Suit != 3
   sound_play_pos(sndGrip,x,y-10);
   else
   sound_play_pos(sndGripZero,x,y-10);
   
  global.KeyPushed[0,KEY_UP] = 0;
  image_index = 0;
 }
 
 if global.KeyPushed[0,KEY_LEFT]
 if position_meeting(x-8,y-26,oSolid) &amp;&amp; !position_meeting(x-8,y-32,oSolid) &amp;&amp; place_meeting(x-1,y,oSolid) &amp;&amp; Facing == -1
 {
  y += 1;
  move_snap(1,16)
  y -= 5;
  
  repeat (10) 
  {
   if !place_meeting(x-1,y,oSolid)
   {
    x --;
    collision_bounds(0);
   }
  }
  
  State = GRIP; 
  TrueFacing = -1;
  Facing = -1;
  
  if global.Suit != 3
   sound_play_pos(sndGrip,x,y-10);
   else
   sound_play_pos(sndGripZero,x,y-10);

  global.KeyPushed[0,KEY_UP] = 0;
  image_index = 0;
 } 
}

if State == GRIP
if !(TrueFacing == 1 &amp;&amp; collision_right(0,1) or (TrueFacing == -1 &amp;&amp; collision_left(0,1)))
{
 State = JUMPING;

}


if State == GRIP or State == CLIMBING or State == WALL
{
 xVel = 0;
 yVel = 0;
}


if State == GRIP &amp;&amp; (global.KeyPushed[0,KEY_UP]&gt;15 or (global.KeyPushed[0,KEY_RIGHT] &amp;&amp; TrueFacing == 1 &amp;&amp; global.KeyPressed[0,KEY_A]) or (global.KeyPushed[0,KEY_LEFT] &amp;&amp; TrueFacing == -1 &amp;&amp; global.KeyPressed[0,KEY_A]))
{
 if !((global.Suit == 3 or !global.Power[P_MORPHBALL]) &amp;&amp; (position_meeting(x + TrueFacing*10, y - 59,oSolid) or position_meeting(x + TrueFacing, y - 59,oSolid))) &amp;&amp; !place_meeting(x,y-10,oSolid) 
 {
  StateTime = 0;
  State = CLIMBING;
  
  if global.Suit != 3
   sound_play_pos(sndClimb,x,y-10);
   else
   sound_play_pos(sndClimbZero,x,y-10); 
    
  Facing = TrueFacing;
 }
 else
 if (global.KeyPushed[0,KEY_RIGHT] &amp;&amp; TrueFacing == 1 &amp;&amp; global.KeyPressed[0,KEY_A]) or (global.KeyPushed[0,KEY_LEFT] &amp;&amp; TrueFacing == -1 &amp;&amp; global.KeyPressed[0,KEY_A])
 {
  if !InWater
   yVel = -JumpHeight/1.435;
   else
   yVel = -JumpHeightWater/1.435;
  
  MoveTick = 1;
  yMP = 0;
  yMN = 0;
  image_index = 0;
    
  Spinning = 0;
  State = JUMPING;
  Turning = 0;
  Landing = 0; 
 }
}
else
if State == GRIP &amp;&amp; global.KeyPressed[0,KEY_A] &amp;&amp; Facing == TrueFacing
{
 if !InWater
  yVel = -JumpHeight/1.435;
  else
  yVel = -JumpHeightWater/1.435;
 
 MoveTick = 1;
 yMP = 0;
 yMN = 0;
 image_index = 0;
   
 Spinning = 0;
 State = JUMPING;
 Turning = 0;
 Landing = 0;
}

if State == GRIP &amp;&amp; global.KeyPressed[0,KEY_A] &amp;&amp; Facing != TrueFacing &amp;&amp; ((global.KeyPushed[0,KEY_RIGHT] &amp;&amp; Facing == 1) or (global.KeyPushed[0,KEY_LEFT] &amp;&amp; Facing == -1))
{
 if !InWater
  yVel = -JumpHeight;
  else
  yVel = -JumpHeightWater;
 
 MoveTick = 1;
 yMP = 0;
 yMN = 0;
 image_index = 0;
   
 Spinning = 1;
 State = JUMPING;
 Turning = 0;
 Landing = 0;
 
 xVel = Facing;
}
else
if State == GRIP &amp;&amp; global.KeyPressed[0,KEY_A] &amp;&amp; Facing != TrueFacing &amp;&amp; !((global.KeyPushed[0,KEY_RIGHT] &amp;&amp; Facing == 1) or (global.KeyPushed[0,KEY_LEFT] &amp;&amp; Facing == -1))
{ 
 MoveTick = 1;
 yMP = 0;
 yMN = 0;
 image_index = 0;
   
 Spinning = 0;
 State = JUMPING;
 Turning = 0;
 Landing = 0;
 
 yVel = 10/32;
 xVel = 0;
}



if State == CLIMBING 
{
 CanTurn = 0;

 if StateTime == 0 // Executed twice`!
 {
  MorphClimb = position_meeting(x + Facing*10, y - 43,oSolid) or position_meeting(x + Facing, y - 43,oSolid);
  y -= 2;
 }

  if StateTime = 1
   y -= 4;
  if StateTime = 2
   y -= 4;
  if StateTime = 3
   y -= 3;
  if StateTime = 4
   y -= 3;
  if StateTime = 5
   y -= 2;
  if StateTime = 6
   y -= 2;
  if StateTime = 7
   y -= 1;
  if StateTime = 8
   y -= 1;
  if StateTime = 9
   y -= 1;

 if StateTime == 21
 {
  Landing = 0;
  State = STANDING;
  StateTime = 0;
  image_index = 0;
  CanTurn = 1;
  if Facing == 1 &amp;&amp; global.KeyPushed[0,KEY_LEFT]
  {
   Facing = -1;
   Turning = 1;
   Landing = 0;
  }
  else
  if Facing == -1 &amp;&amp; global.KeyPushed[0,KEY_RIGHT]
  {
   Facing = 1;
   Turning = 1;
   Landing = 0;
  }
 } 

  if (floor(StateTime) == 9 &amp;&amp; (MorphClimb or (position_meeting(x+Facing*8,y-10,oSolid) or position_meeting(x - Facing, y - 10,oSolid))))
  {
   y -= 1;
   x += Facing;
   State = BALL;
   BallAngle = 0;
   sound_play_pos(sndMorph,x,y);
   StateTime = 0;
   image_index = 1; 
 }      
 
 if Facing == 1 
 {
  if StateTime=8 y--;
  if StateTime=9  y--;
  if StateTime=10 x++;
  if StateTime=11  x++//move_to_simple(1,0);
  if StateTime=12 x++//move_to_simple(1,0);
  if StateTime=13  x++//move_to_simple(1,0);
  if StateTime&gt;13 &amp;&amp; StateTime &lt; 20 &amp;&amp; floor(StateTime) == StateTime x++//move_to_simple(1,0);
 }
 if Facing == -1 
 {
  if StateTime=8 y--;
  if StateTime=9  y--;
  if StateTime=10 x--;
  if StateTime=11  x--//move_to_simple(-1,0);
  if StateTime=12 x--//move_to_simple(-1,0);
  if StateTime=13  x--//move_to_simple(-1,0);
  if StateTime&gt;13 &amp;&amp; StateTime &lt; 20 &amp;&amp; floor(StateTime) == StateTime x--//move_to_simple(-1,0);
 }

 if StateTime&gt;9 and (place_meeting(x,y,oSlope)) y--;
}
 
// FINAL MOVESET

if State != GRIP &amp;&amp; State != CLIMBING
 slope_walk_simple();
 
// FALL IN BALL

if !on_ground_prev &amp;&amp; on_ground(0,1)
if State == BALL &amp;&amp; yVel &gt; 0
{  
 xVel = 0;
 image_index = 1;
 StateTime = 0;
 
 if !(global.Power[P_SPRINGBALL] &amp;&amp; global.KeyPushed[0,KEY_A] &amp;&amp; !collision_top(0,5))
 {
  if yVel &gt; 5 &amp;&amp; !InWater
   yVel = -1.5;
 }
 else
 JustSpring = 3;
 
 if !PlayBounce
 {
  PlayBounce = 6;
  sound_play_pos(sndBounce,x,y);
 }
}

// HEAD BUMP

if yVel &lt; 0 &amp;&amp; collision_top(0,1)
{ 
 yVel = 10/32;
}

// GET OFF OF MOVING SOLIDS

if !on_ground(0,1) &amp;&amp; OnMoving &gt; 0
{
 if OnMoving.xVel &gt; 0
 {
  xVel = min(xVel + OnMoving.xVel, xMax);
 } 
 else
 {
  xVel = max(xVel + OnMoving.xVel, -xMax);
 } 
}

// AIMING

if !Turning
{
 if State == STANDING or State == JUMPING or State == RUNNING or State == BRAKING              
 {
  if !global.KeyPushed[0,KEY_POWER]
  {
   if !((AimDirection == 8 or AimDirection == 0) &amp;&amp; State == JUMPING)
    AimTarget = 4;
    else
    if ((Facing &amp;&amp; global.KeyPushed[0,KEY_RIGHT]) or (Facing == -1 &amp;&amp; global.KeyPushed[0,KEY_LEFT]))
    &amp;&amp; !global.KeyPushed[0,KEY_DOWN] &amp;&amp; !global.KeyPushed[0,KEY_UP]
    AimTarget = 4;
    
    
   if Spinning &amp;&amp; State == JUMPING
   {
    if AimDirection != 0 &amp;&amp; global.KeyPushed[0,KEY_DOWN]
    &amp;&amp; !((Facing &amp;&amp; global.KeyPushed[0,KEY_RIGHT]) or (Facing == -1 &amp;&amp; global.KeyPushed[0,KEY_LEFT]))
    {
     Spinning = 0;
     set_collision(0,-7,-31,8,0);
     mask_index = sMask;
     while collision_top(0,0) y++;
     AimDirection = 0;
     xVel = 0;
     yVel = 0;
     if global.Power[P_SCREW] &amp;&amp; !InWater &amp;&amp; global.Suit != 3
      sound_play_pos(sndScrewStop,x,y);
    }
    if AimDirection != 8 &amp;&amp; global.KeyPushed[0,KEY_UP] 
    &amp;&amp; !((Facing &amp;&amp; global.KeyPushed[0,KEY_RIGHT]) or (Facing == -1 &amp;&amp; global.KeyPushed[0,KEY_LEFT]))
    {
     Spinning = 0;
     set_collision(0,-7,-31,8,0);
     mask_index = sMask;
     while collision_top(0,0) y++;
     AimDirection = 8;
     xVel = 0;
     yVel = 0;
     if global.Power[P_SCREW] &amp;&amp; !InWater &amp;&amp; global.Suit != 3
      sound_play_pos(sndScrewStop,x,y);
    }  
   }
   
   if !CanAimUp
   if global.KeyPushed[0,KEY_UP]
   {
    if State != RUNNING
     AimTarget = 8;
    if (Facing &amp;&amp; global.KeyPushed[0,KEY_RIGHT])
    or (Facing == -1 &amp;&amp; global.KeyPushed[0,KEY_LEFT])
     AimTarget = 6;    
   }
   if global.KeyPushed[0,KEY_DOWN]
   {
    if State == JUMPING
     AimTarget = 0;  
    if (Facing &amp;&amp; global.KeyPushed[0,KEY_RIGHT])
    or (Facing == -1 &amp;&amp; global.KeyPushed[0,KEY_LEFT])
     AimTarget = 2;    
   }
  }
  else
  {
   if AimTarget != 2 &amp;&amp; AimTarget != 6
    AimTarget = 6;
   
   if global.KeyPushed[0,KEY_DOWN]
    AimTarget = 2; 
   if global.KeyPushed[0,KEY_UP]
    AimTarget = 6;    
  }
 }
 
 if State == DUCKING
 {
  if !global.KeyPushed[0,KEY_POWER]
  {
   AimTarget = 4;
  }
  else
  {
   if AimTarget != 2 &amp;&amp; AimTarget != 6
    AimTarget = 6;
   
   if global.KeyPushed[0,KEY_DOWN]
    AimTarget = 2; 
   if global.KeyPushed[0,KEY_UP]
    AimTarget = 6;    
  }
  if ForceAim AimDirection = 4;
 }
 
 if State == GRIP
 {
  if !global.KeyPushed[0,KEY_POWER]
  {
   if AimDirection == 2 or AimDirection == 6
    AimTarget = 4;
   
   if global.KeyPushed[0,KEY_UP] AimTarget = 8;
   if global.KeyPushed[0,KEY_DOWN] AimTarget = 0;
   
   if global.KeyPushed[0,KEY_UP]
   {
    if (Facing &amp;&amp; global.KeyPushed[0,KEY_RIGHT])
    or (Facing == -1 &amp;&amp; global.KeyPushed[0,KEY_LEFT])
     AimTarget = 6;
   }
   else
   if global.KeyPushed[0,KEY_DOWN]
   {
    if (Facing &amp;&amp; global.KeyPushed[0,KEY_RIGHT])
    or (Facing == -1 &amp;&amp; global.KeyPushed[0,KEY_LEFT])
     AimTarget = 2;     
   }
   else
   {
    if (Facing &amp;&amp; global.KeyPushed[0,KEY_RIGHT])
    or (Facing == -1 &amp;&amp; global.KeyPushed[0,KEY_LEFT])
     AimTarget = 4;
   } 
   
   if AimTarget != 8 global.KeyPushed[0,KEY_UP] = min(1,global.KeyPushed[0,KEY_UP]);
  }
  else
  {   
   global.KeyPushed[0,KEY_UP] = min(1,global.KeyPushed[0,KEY_UP]);
   if AimTarget != 2 &amp;&amp; AimTarget != 6
    AimTarget = 6;
   
   if global.KeyPushed[0,KEY_DOWN]
    AimTarget = 2; 
   if global.KeyPushed[0,KEY_UP]
    AimTarget = 6;     
  } 
  
  if AimTarget != 4 &amp;&amp; Facing == TrueFacing &amp;&amp; !Turning
  {
   Turning = 1;
   image_index = 0;  
   Facing = TrueFacing*-1;  
  } 
  else
  if Facing == TrueFacing &amp;&amp; !Turning
  AimTarget = 4;
 }
 
 if !SmoothAim
  AimDirection = AimTarget;
  else
  {
   if AimDirection &gt; AimTarget
    AimDirection -= AimSpeed;
   if AimDirection &lt; AimTarget
    AimDirection += AimSpeed;
  }
 
 if ForceAim AimDirection = 4;
 if State == RUNNING &amp;&amp; AimDirection &gt; 6 AimDirection = 6; 
}
else
if State == RUNNING State = STANDING;

if State == RUNNING &amp;&amp; AimDirection &gt; 6 AimDirection = 6; 

if Firing != 0
{
 Firing ++;
 if (Firing &gt; 4 &amp;&amp; (global.Suit != 3 or State == GRIP)) or (Firing &gt; 6 &amp;&amp; global.Suit == 3 &amp;&amp; State != GRIP)
 {
  Firing = 0;
  if global.Suit == 3 &amp;&amp; State != GRIP
   image_index = 5;
   else
   image_index = 0;
 }
}


// SHOOOOOOOOOOOOOOOOOOOOT

samus_fire();

if AimDirection != 4 Aiming = 1;
if State != RUNNING or Turning Aiming = 0;

if ForceAimDiag 
{
 AimDirection = 2;
 ForceAimDiag --;
}

// FINISHED

sprite_control();

ONTHEGROUND = place_meeting(ds_list_find_value(xPrevv,4),ds_list_find_value(yPrevv,4)+1,oSolid)
or place_meeting(ds_list_find_value(xPrevv,3),ds_list_find_value(yPrevv,3)+1,oSolid)
or place_meeting(ds_list_find_value(xPrevv,5),ds_list_find_value(yPrevv,5)+1,oSolid)
or place_meeting(ds_list_find_value(xPrevv,6),ds_list_find_value(yPrevv,6)+1,oSolid)
or place_meeting(ds_list_find_value(xPrevv,2),ds_list_find_value(yPrevv,2)+1,oSolid);

set_collision(0,-7,-31,8,0);

mask_index = sMask;

if (State == JUMPING &amp;&amp; Spinning) or State == WALL or State == DUCKING or State == CRAWL or State == UNCRAWL or State == GRIP or (State == CLIMBING &amp;&amp; image_index &lt; 6)
{

 set_collision(0,-7,-23,8,0);
 mask_index = sMaskDuck;
}

if State == BALL or (State == CLIMBING &amp;&amp; MorphClimb) or State == CRAWLING or (SuperBall)
{
 set_collision(0,-7,-15,8,0);
 mask_index = sMaskBall;
}


if State != IDLE
{
 while collision_top(0,0) &amp;&amp; State != CLIMBING
 {
   y ++;
   collision_bounds(0);
 }
 while collision_bottom(0,0) &amp;&amp; !collision_top(0,1)
 {
   y --;
   collision_bounds(0);
 }
}

StateTime ++; 

if State != StatePrev &amp;&amp; StatePrev != SUPERJUMP StateTime = 0; 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oBombExplosion">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if global.PausedGame exit;

xx = x;
C[2] = !collision_top(0,9);
x += 2;
C[0] = !collision_top(0,9);
x -= 4;
C[1] = !collision_top(0,9);
x = xx;


if (State==BALL) &amp;&amp; other.Touched=0 &amp;&amp; other.image_index &lt; 5 &amp;&amp; !InWater &amp;&amp; (C[0] or C[1] or C[2])
if y - 8&lt;= other.y &amp;&amp; y - 8&gt;= other.y - 16
{
 other.Touched = 1;
 yVel =- 174/32;
 State = BALL;
 StateTime = 0;
 
 if x&lt;(other.x)
 {
  Facing = -1
  xVel = -1.25;
 }
    
 if x&gt;(other.x)
 {
  Facing = 1;
  xVel = 1.25;
 }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw

FinalSprite = sprite_index;
FinalTorso = TorsoSprite;

suit_handle();
 
effect_handle()

// Other shizz

Divisor = 1.4;
if BeamFade
 Divisor = 1;

if yVel &lt; 0 or (Dash&gt;DashTime or State=SJSTART or State=SUPERJUMP) or Dash &gt; 0 or State == BRAKING
for (i=0;i&lt;8;i++)
if i == tPrevv
if ds_list_find_value(yVell,i*2) &lt;= 0 or (Dash&gt;DashTime or State=SJSTART or State=SUPERJUMP) or Dash &gt; 0 or State == BRAKING
if State != SJSTART &amp;&amp; State != HURT
{
 draw_sprite_ext(FinalSprite, image_index, ds_list_find_value(xPrevv,i*Mult), ds_list_find_value(yPrevv,i*Mult), Legs, image_yscale, image_angle, CC, AA); 
 draw_sprite_ext(FinalTorso, TorsoIndex,ds_list_find_value(xPrevv,i*Mult)+TorsoX, ds_list_find_value(yPrevv,i*Mult)+TorsoY, Mirror, image_yscale, image_angle, CC, AA);
 draw_sprite_ext(ArmSprite, 0,ds_list_find_value(xPrevv,i*Mult)+ArmX, ds_list_find_value(yPrevv,i*Mult)+ArmY, ArmFacing, image_yscale, image_angle, CC, AA*ArmVis); 
 
 if Rushing or HurtPalette
 {
  if HurtPalette
   fog_on(HurtBlend[Num3]);
  if Rushing or Charge
   fog_on(BoostBlend[Num]);
   
  if !((Num == 0 &amp;&amp; (Rushing or Charge)) or (Num3 == 0 &amp;&amp; HurtPalette &amp;&amp; !(Rushing or Charge)))
   draw_set_blend_mode(bm_add);
  draw_sprite_ext(FinalSprite, image_index, ds_list_find_value(xPrevv,i*Mult), ds_list_find_value(yPrevv,i*Mult), Legs, image_yscale, image_angle, CC, AA/Divisor); 
  draw_sprite_ext(FinalTorso, TorsoIndex,ds_list_find_value(xPrevv,i*Mult)+TorsoX, ds_list_find_value(yPrevv,i*Mult)+TorsoY, Mirror, image_yscale, image_angle, CC, AA/Divisor);
  draw_sprite_ext(ArmSprite, 0,x+ArmX, y+ArmY, ArmFacing, image_yscale, image_angle, CC, AA/Divisor*ArmVis);
  draw_set_blend_mode(bm_normal);;
 
  fog_off(BoostBlend[0]); 
 }
}

draw_sprite_ext(FinalSprite, image_index, x, y, Legs, image_yscale, image_angle, image_blend, image_alpha); 
draw_sprite_ext(FinalTorso, TorsoIndex,x+TorsoX, y+TorsoY, Mirror, image_yscale, image_angle, image_blend, image_alpha);
draw_sprite_ext(ArmSprite, 0,x+ArmX, y+ArmY, ArmFacing, image_yscale, image_angle, image_blend, image_alpha*ArmVis);     

shader_reset();

if WhiteFade &gt; 0
{
 d3d_set_fog(1,-1,0,0);
 draw_sprite_ext(FinalSprite, image_index, x, y, Legs, image_yscale, image_angle, image_blend, image_alpha*WhiteFade); 
 draw_sprite_ext(FinalTorso, TorsoIndex,x+TorsoX, y+TorsoY, Mirror, image_yscale, image_angle, image_blend, image_alpha*WhiteFade);
 draw_sprite_ext(ArmSprite, 0,x+ArmX, y+ArmY, ArmFacing, image_yscale, image_angle, image_blend, image_alpha*ArmVis*WhiteFade);  
 d3d_set_fog(0,-1,0,0); 
 if !global.PausedGame &amp;&amp; view_current == 0
 WhiteFade = max(WhiteFade-.1,0);
}

if Rushing or HurtPalette or BeamFade
{
 if BeamFade
  fog_on(BeamHue);
 if HurtPalette 
   fog_on(HurtBlend[Num3]);
 if Rushing or Charge
   fog_on(BoostBlend[Num]);
  
 if !((Num == 0 &amp;&amp; (Rushing or Charge)) or (Num3 == 0 &amp;&amp; HurtPalette &amp;&amp; !(Rushing or Charge)))
  draw_set_blend_mode(bm_add);
  
 draw_sprite_ext(FinalSprite, image_index, x, y, Legs, image_yscale, image_angle, image_blend, AA/Divisor); 
 draw_sprite_ext(FinalTorso, TorsoIndex,x+TorsoX, y+TorsoY, Mirror, image_yscale, image_angle, image_blend, AA/Divisor);
 draw_sprite_ext(ArmSprite, 0,x+ArmX, y+ArmY, ArmFacing, image_yscale, image_angle, image_blend, AA/Divisor*ArmVis);

 draw_set_blend_mode(bm_normal);
 
 fog_off(BoostBlend[0]);
}
if view_current == 0
{
 if Dash&gt;=DashTime &amp;&amp; State == RUNNING
 {
  draw_set_blend_mode(bm_add);
  for(nnnnnnnnnn=0;nnnnnnnnnn&lt;global.sbrungraphs[0,1];nnnnnnnnnn+=1)
  {
    if global.sbrungraphs[nnnnnnnnnn,0]=0 &amp;&amp; global.PausedGame == 0
   {
    global.sbrungraph[nnnnnnnnnn,0] = irandom(12);
    global.sbrungraph[nnnnnnnnnn,1] = irandom(40);
   }
   draw_sprite_ext(sSSpeedRunning,global.sbrungraphs[nnnnnnnnnn,0],((x))+(global.sbrungraph[nnnnnnnnnn,0])-(16*(Facing==1)),y+global.sbrungraph[nnnnnnnnnn,1]-6,Facing,1,0,global.boostlights[Num2],image_alpha)
  
   if !global.PausedGame
   global.sbrungraphs[nnnnnnnnnn,0]+=1;
  
   if global.sbrungraphs[nnnnnnnnnn,0]=6
   global.sbrungraphs[nnnnnnnnnn,0]=0
  }
 
  global.sbrungraphs[0,1]=min(global.sbrungraphes,global.sbrungraphs[0,1]+0.25)
  draw_set_blend_mode(bm_normal); 
 }
 else
 {
  for(nnnnnnnnnn=0;nnnnnnnnnn&lt;global.sbrungraphes;nnnnnnnnnn+=1)
   global.sbrungraphs[nnnnnnnnnn,0]=0
  global.sbrungraphs[0,1]=0
 }
}

afterdraw_handle();


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>10,28</point>
    <point>14,14</point>
  </PhysicsShapePoints>
</object>
